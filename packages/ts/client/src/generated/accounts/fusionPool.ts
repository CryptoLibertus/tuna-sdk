/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI32Decoder,
  getI32Encoder,
  getStructDecoder,
  getStructEncoder,
  getU128Decoder,
  getU128Encoder,
  getU16Decoder,
  getU16Encoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';

export const FUSION_POOL_DISCRIMINATOR = new Uint8Array([
  254, 204, 207, 98, 25, 181, 29, 67,
]);

export function getFusionPoolDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(FUSION_POOL_DISCRIMINATOR);
}

export type FusionPool = {
  discriminator: ReadonlyUint8Array;
  bump: ReadonlyUint8Array;
  version: number;
  tokenMintA: Address;
  tokenMintB: Address;
  tokenVaultA: Address;
  tokenVaultB: Address;
  tickSpacing: number;
  tickSpacingSeed: ReadonlyUint8Array;
  feeRate: number;
  protocolFeeRate: number;
  clpToOlpRewardRatio: number;
  orderProtocolFeeRate: number;
  liquidity: bigint;
  sqrtPrice: bigint;
  tickCurrentIndex: number;
  protocolFeeOwedA: bigint;
  protocolFeeOwedB: bigint;
  feeGrowthGlobalA: bigint;
  feeGrowthGlobalB: bigint;
  ordersTotalAmountA: bigint;
  ordersTotalAmountB: bigint;
  ordersFilledAmountA: bigint;
  ordersFilledAmountB: bigint;
  olpFeeOwedA: bigint;
  olpFeeOwedB: bigint;
  reserved: ReadonlyUint8Array;
};

export type FusionPoolArgs = {
  bump: ReadonlyUint8Array;
  version: number;
  tokenMintA: Address;
  tokenMintB: Address;
  tokenVaultA: Address;
  tokenVaultB: Address;
  tickSpacing: number;
  tickSpacingSeed: ReadonlyUint8Array;
  feeRate: number;
  protocolFeeRate: number;
  clpToOlpRewardRatio: number;
  orderProtocolFeeRate: number;
  liquidity: number | bigint;
  sqrtPrice: number | bigint;
  tickCurrentIndex: number;
  protocolFeeOwedA: number | bigint;
  protocolFeeOwedB: number | bigint;
  feeGrowthGlobalA: number | bigint;
  feeGrowthGlobalB: number | bigint;
  ordersTotalAmountA: number | bigint;
  ordersTotalAmountB: number | bigint;
  ordersFilledAmountA: number | bigint;
  ordersFilledAmountB: number | bigint;
  olpFeeOwedA: number | bigint;
  olpFeeOwedB: number | bigint;
  reserved: ReadonlyUint8Array;
};

export function getFusionPoolEncoder(): Encoder<FusionPoolArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['bump', fixEncoderSize(getBytesEncoder(), 1)],
      ['version', getU16Encoder()],
      ['tokenMintA', getAddressEncoder()],
      ['tokenMintB', getAddressEncoder()],
      ['tokenVaultA', getAddressEncoder()],
      ['tokenVaultB', getAddressEncoder()],
      ['tickSpacing', getU16Encoder()],
      ['tickSpacingSeed', fixEncoderSize(getBytesEncoder(), 2)],
      ['feeRate', getU16Encoder()],
      ['protocolFeeRate', getU16Encoder()],
      ['clpToOlpRewardRatio', getU16Encoder()],
      ['orderProtocolFeeRate', getU16Encoder()],
      ['liquidity', getU128Encoder()],
      ['sqrtPrice', getU128Encoder()],
      ['tickCurrentIndex', getI32Encoder()],
      ['protocolFeeOwedA', getU64Encoder()],
      ['protocolFeeOwedB', getU64Encoder()],
      ['feeGrowthGlobalA', getU128Encoder()],
      ['feeGrowthGlobalB', getU128Encoder()],
      ['ordersTotalAmountA', getU64Encoder()],
      ['ordersTotalAmountB', getU64Encoder()],
      ['ordersFilledAmountA', getU64Encoder()],
      ['ordersFilledAmountB', getU64Encoder()],
      ['olpFeeOwedA', getU64Encoder()],
      ['olpFeeOwedB', getU64Encoder()],
      ['reserved', fixEncoderSize(getBytesEncoder(), 140)],
    ]),
    (value) => ({ ...value, discriminator: FUSION_POOL_DISCRIMINATOR })
  );
}

export function getFusionPoolDecoder(): Decoder<FusionPool> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['bump', fixDecoderSize(getBytesDecoder(), 1)],
    ['version', getU16Decoder()],
    ['tokenMintA', getAddressDecoder()],
    ['tokenMintB', getAddressDecoder()],
    ['tokenVaultA', getAddressDecoder()],
    ['tokenVaultB', getAddressDecoder()],
    ['tickSpacing', getU16Decoder()],
    ['tickSpacingSeed', fixDecoderSize(getBytesDecoder(), 2)],
    ['feeRate', getU16Decoder()],
    ['protocolFeeRate', getU16Decoder()],
    ['clpToOlpRewardRatio', getU16Decoder()],
    ['orderProtocolFeeRate', getU16Decoder()],
    ['liquidity', getU128Decoder()],
    ['sqrtPrice', getU128Decoder()],
    ['tickCurrentIndex', getI32Decoder()],
    ['protocolFeeOwedA', getU64Decoder()],
    ['protocolFeeOwedB', getU64Decoder()],
    ['feeGrowthGlobalA', getU128Decoder()],
    ['feeGrowthGlobalB', getU128Decoder()],
    ['ordersTotalAmountA', getU64Decoder()],
    ['ordersTotalAmountB', getU64Decoder()],
    ['ordersFilledAmountA', getU64Decoder()],
    ['ordersFilledAmountB', getU64Decoder()],
    ['olpFeeOwedA', getU64Decoder()],
    ['olpFeeOwedB', getU64Decoder()],
    ['reserved', fixDecoderSize(getBytesDecoder(), 140)],
  ]);
}

export function getFusionPoolCodec(): Codec<FusionPoolArgs, FusionPool> {
  return combineCodec(getFusionPoolEncoder(), getFusionPoolDecoder());
}

export function decodeFusionPool<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<FusionPool, TAddress>;
export function decodeFusionPool<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<FusionPool, TAddress>;
export function decodeFusionPool<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<FusionPool, TAddress> | MaybeAccount<FusionPool, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getFusionPoolDecoder()
  );
}

export async function fetchFusionPool<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<FusionPool, TAddress>> {
  const maybeAccount = await fetchMaybeFusionPool(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeFusionPool<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<FusionPool, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeFusionPool(maybeAccount);
}

export async function fetchAllFusionPool(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<FusionPool>[]> {
  const maybeAccounts = await fetchAllMaybeFusionPool(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeFusionPool(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<FusionPool>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeFusionPool(maybeAccount));
}

export function getFusionPoolSize(): number {
  return 423;
}
